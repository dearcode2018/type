/**
 * ByteServiceImpl.java
 * @author  qye.zheng
 * 	version 1.0
 */
package com.hua.service.impl;

import com.hua.service.ByteService;

/**
 * ByteServiceImpl
 * 描述: 
 * @author  qye.zheng
 */
public final class ByteServiceImpl extends CoreServiceImpl implements
		ByteService
{

	/**
	 字节分析
	 一) 基本分析
	 字节(byte) = 8 个比特
	 
	 1 byte = 8 bit
	 
	 1 kb = 1024 b
	 1 mb = 1024 kb
	 1 gb = 1024 mb
	 1 tb = 1024 gb
	 
	 基本类型: byte
	 包装类型:  java.lang.Byte
	 
	 二) 字节结构
	 一个字节 8个二进制位，第一位是符号位，剩下7位
	 是数值位.
	 字节_模 = 2^7
	 范围_正数: 00000000 ~ 01111111 --> [0, 2^7-1] = [0, 127] --> [0, 127)
	 范围_负数: 11111111 ~ 10000000 -进入计算机-补码表示-> 10000001 ~ 00000000
	 -转成十进制形式-> 0 ~ -128
	 范围_整体: 
	 
	 // 参考解说
	当符号位为0时,00000000到01111111对应了数轴上从0到127这些数字
	当符号位为1时,10000000到11111111对应了数轴上从-128到-1这些数字
	这样整个数轴就完整地表示为-128到127,因为数轴上定义了从小到大表示从左向右,
	无论正负都是这个规则,所以出现了补码计算的方法,如果不用补码,
	单纯用符号位加右7位的值,那么在数轴上的负数就娈成了正数的对称结构,
	从小到大表示从右到左,与数轴的定义相背,所以符号位为1时,后面全0表示的是最小的负数
	 
	 在n位二进制中，除了最小的负数不能通过推敲其原码来观察其值，其他值都是可以的，
	 而且有个特点，仅有最小负数的补码等于其原码；
	 
	 */
	
	/**
	 移位运算
	 
	 移位运算符就是在二进制的基础上对数字进行平移。
	 按照平移的方向和填充数字的规则分为三种：<<（左移）、>>（带符号右移）和>>>（无符号右移）
	 (左移 无需考虑符号，由最左边第二位来决定, 用0填充右边)
	 右移: 需要考虑移位发生后，最高位由什么来 填充.
	 >> 带符号右移(常规移位)，即符号位保持不变，右移位消失.
	 >>> 无符号右移 (高位的空位补零)
	 
	 无符号右移，就是在右移中不考虑符号位.
	 
	 注意:
	 由于无符号右移运算符>>> 只是对32位和64位的值有意义，所以它并不像你想象的那样有用。
	 因为你要记住，在表达式中过小的值总是被自动扩大为int 型。这意味着符号位扩展和移动总是发生在32位而不是8位或16位。
	 这样，对第7位以0开始的byte 型的值进行无符号移动是不可能的，因为在实际移动运算时，是对扩大后的32位值进行操作。
	 
	 
	 */
	
}
